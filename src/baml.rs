//! BAML runtime wrapper and function execution

use crate::baml_execution::BamlExecutor;
use crate::error::{BamlRtError, Result};
use crate::types::FunctionSignature;
use crate::tools::{ToolRegistry, ToolMetadata};
use crate::tool_mapper::ToolMapper;
use serde_json::Value;
use std::collections::HashMap;
use std::future::Future;
use std::sync::Arc;
use tokio::sync::Mutex as TokioMutex;

// BAML executes in Rust. We will implement execution of BAML functions
// in Rust, then map those function calls to QuickJS so JavaScript can invoke them.
// use baml;

/// Manages the BAML runtime and function registry
pub struct BamlRuntimeManager {
    function_registry: HashMap<String, FunctionSignature>,
    pub(crate) executor: Option<BamlExecutor>,
    tool_registry: Arc<TokioMutex<ToolRegistry>>,
    tool_mapper: ToolMapper,
}

impl BamlRuntimeManager {
    /// Create a new BAML runtime manager
    pub fn new() -> Result<Self> {
        tracing::info!("Initializing BAML runtime manager");
        
        Ok(Self {
            function_registry: HashMap::new(),
            executor: None,
            tool_registry: Arc::new(TokioMutex::new(ToolRegistry::new())),
            tool_mapper: ToolMapper::new(),
        })
    }

    /// Load a compiled BAML schema/configuration
    /// 
    /// This loads the BAML IL (Intermediate Language) generated by baml-cli generate
    /// and registers all available functions.
    /// 
    /// The schema_path should point to the baml_src directory.
    pub fn load_schema(&mut self, schema_path: &str) -> Result<()> {
        tracing::info!(schema_path = schema_path, "Loading BAML IL");
        
        use std::path::Path;
        use std::fs;
        
        // Find project root
        let schema_path_obj = Path::new(schema_path);
        let project_root = if schema_path_obj.is_file() {
            schema_path_obj.parent()
                .and_then(|p| p.parent())
        } else {
            if schema_path_obj.file_name() == Some(std::ffi::OsStr::new("baml_src")) {
                schema_path_obj.parent()
            } else {
                Some(schema_path_obj)
            }
        }
        .ok_or_else(|| BamlRtError::InvalidArgument("Invalid schema path".to_string()))?;
        
        let client_dir = project_root.join("baml_client");
        if !client_dir.exists() {
            return Err(BamlRtError::BamlRuntime(
                format!("baml_client directory not found. Run 'baml-cli generate' first.")
            ));
        }
        
        let baml_src_dir = project_root.join("baml_src");
        if !baml_src_dir.exists() {
            return Err(BamlRtError::BamlRuntime(
                "baml_src directory not found".to_string()
            ));
        }
        
        // Load BAML IL into executor (pass tool registry)
        let tool_registry_clone = self.tool_registry.clone();
        self.executor = Some(BamlExecutor::load_il(&client_dir, &baml_src_dir, tool_registry_clone)?);
        
        // Discover functions from generated code for registration
        let inlined_file = client_dir.join("inlinedbaml.ts");
        if inlined_file.exists() {
            let content = fs::read_to_string(&inlined_file)
                .map_err(|e| BamlRtError::Io(e))?;
            
            use regex::Regex;
            let re = Regex::new(r"function\s+(\w+)\s*\(").unwrap();
            for cap in re.captures_iter(&content) {
                let func_name = cap.get(1).unwrap().as_str().to_string();
                
                // Functions are discovered from the runtime's IR, not stored separately
                
                // Register function signature
                self.function_registry.insert(
                    func_name.clone(),
                    FunctionSignature {
                        name: func_name.clone(),
                        input_types: vec![],
                        output_type: crate::types::BamlType::String,
                    },
                );
            }
        }
        
        tracing::info!(
            function_count = self.function_registry.len(),
            "Loaded BAML IL"
        );
        
        Ok(())
    }

    /// Get the signature of a function by name
    pub fn get_function_signature(&self, name: &str) -> Option<&FunctionSignature> {
        self.function_registry.get(name)
    }

    /// Execute a BAML function with the given arguments
    pub async fn invoke_function(
        &self,
        function_name: &str,
        args: serde_json::Value,
    ) -> Result<serde_json::Value> {
        tracing::debug!(
            function = function_name,
            args = ?args,
            "Invoking BAML function"
        );

        // Verify function exists
        let _signature = self
            .function_registry
            .get(function_name)
            .ok_or_else(|| BamlRtError::FunctionNotFound(function_name.to_string()))?;

        // Execute the BAML function using the executor
        let executor = self.executor.as_ref()
            .ok_or_else(|| BamlRtError::BamlRuntime("BAML runtime not loaded".to_string()))?;
        
        // Pass tool registry to executor for potential integration
        let tool_registry = Some(self.tool_registry.clone());
        executor.execute_function(function_name, args, tool_registry).await
    }

    /// Invoke a BAML function with streaming support
    /// 
    /// Returns a stream that yields incremental results as the function executes.
    pub fn invoke_function_stream(
        &self,
        function_name: &str,
        args: serde_json::Value,
    ) -> Result<baml_runtime::FunctionResultStream> {
        tracing::debug!(
            function = function_name,
            args = ?args,
            "Invoking BAML function with streaming"
        );

        // Verify function exists
        let _signature = self
            .function_registry
            .get(function_name)
            .ok_or_else(|| BamlRtError::FunctionNotFound(function_name.to_string()))?;

        // Execute the BAML function using the executor
        let executor = self.executor.as_ref()
            .ok_or_else(|| BamlRtError::BamlRuntime("BAML runtime not loaded".to_string()))?;
        
        executor.execute_function_stream(function_name, args)
    }

    /// List all available BAML functions
    pub fn list_functions(&self) -> Vec<String> {
        self.function_registry.keys().cloned().collect()
    }

    /// Get the tool registry (for tool registration)
    pub fn tool_registry(&self) -> Arc<TokioMutex<ToolRegistry>> {
        self.tool_registry.clone()
    }

    /// Register a tool that implements the BamlTool trait
    /// 
    /// Tools can be called by LLMs during BAML function execution
    /// or directly from JavaScript via the QuickJS bridge.
    /// 
    /// # Example
    /// ```rust,no_run
    /// use baml_rt::baml::BamlRuntimeManager;
    /// use baml_rt::tools::BamlTool;
    /// use serde_json::json;
    /// 
    /// struct MyTool;
    /// 
    /// #[async_trait::async_trait]
    /// impl BamlTool for MyTool {
    ///     const NAME: &'static str = "my_tool";
    ///     fn description(&self) -> &'static str { "Does something" }
    ///     fn input_schema(&self) -> serde_json::Value { json!({}) }
    ///     async fn execute(&self, args: serde_json::Value) -> Result<serde_json::Value> {
    ///         Ok(json!({"result": "success"}))
    ///     }
    /// }
    /// 
    /// let manager = BamlRuntimeManager::new()?;
    /// manager.register_tool(MyTool).await?;
    /// ```
    pub async fn register_tool<T: crate::tools::BamlTool>(&mut self, tool: T) -> Result<()> {
        let mut registry = self.tool_registry.lock().await;
        registry.register(tool)
    }

    /// Execute a tool function by name
    pub async fn execute_tool(&self, name: &str, args: Value) -> Result<Value> {
        let registry = self.tool_registry.lock().await;
        registry.execute(name, args).await
    }

    /// List all registered tools
    pub async fn list_tools(&self) -> Vec<String> {
        let registry = self.tool_registry.lock().await;
        registry.list_tools()
    }

    /// Get tool metadata
    pub async fn get_tool_metadata(&self, name: &str) -> Option<ToolMetadata> {
        let registry = self.tool_registry.lock().await;
        registry.get_metadata(name).cloned()
    }

    /// Map a BAML union variant to a tool function
    /// 
    /// This connects BAML's structured output (union types) to our Rust tool registry.
    /// When BAML returns a union variant representing a tool choice, we can execute
    /// the corresponding Rust tool function.
    /// 
    /// # Arguments
    /// * `baml_variant_name` - The name of the BAML class/union variant (e.g., "WeatherTool")
    /// * `tool_function_name` - The name of the registered Rust tool function (e.g., "get_weather")
    /// 
    /// # Example
    /// ```rust,no_run
    /// // Register a tool
    /// manager.register_tool("get_weather", "...", schema, func).await?;
    /// 
    /// // Map BAML union variant to tool
    /// manager.map_baml_variant_to_tool("WeatherTool", "get_weather");
    /// 
    /// // When BAML returns a WeatherTool variant, it will automatically map to get_weather
    /// ```
    pub fn map_baml_variant_to_tool(
        &mut self,
        baml_variant_name: impl Into<String>,
        tool_function_name: impl Into<String>,
    ) {
        self.tool_mapper.register_mapping(baml_variant_name, tool_function_name);
    }

    /// Execute a tool from a BAML union type result
    /// 
    /// Takes a BAML result (which should be a union variant representing a tool choice),
    /// maps it to the appropriate tool function, and executes it.
    /// 
    /// # Arguments
    /// * `baml_result` - The JSON result from BAML function (union variant)
    /// 
    /// # Returns
    /// The result of executing the tool function
    pub async fn execute_tool_from_baml_result(&self, baml_result: Value) -> Result<Value> {
        self.tool_mapper
            .execute_from_baml_result(baml_result, &self.tool_registry)
            .await
    }
}

impl Default for BamlRuntimeManager {
    fn default() -> Self {
        Self::new().expect("Failed to create BamlRuntimeManager")
    }
}

