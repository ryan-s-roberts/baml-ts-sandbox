//! BAML runtime wrapper and function execution

use crate::baml_execution::BamlExecutor;
use crate::error::{BamlRtError, Result};
use crate::types::FunctionSignature;
use std::collections::HashMap;

// BAML executes in Rust. We will implement execution of BAML functions
// in Rust, then map those function calls to QuickJS so JavaScript can invoke them.
// use baml;

/// Manages the BAML runtime and function registry
pub struct BamlRuntimeManager {
    function_registry: HashMap<String, FunctionSignature>,
    pub(crate) executor: Option<BamlExecutor>,
}

impl BamlRuntimeManager {
    /// Create a new BAML runtime manager
    pub fn new() -> Result<Self> {
        tracing::info!("Initializing BAML runtime manager");
        
        Ok(Self {
            function_registry: HashMap::new(),
            executor: None,
        })
    }

    /// Load a compiled BAML schema/configuration
    /// 
    /// This loads the BAML IL (Intermediate Language) generated by baml-cli generate
    /// and registers all available functions.
    /// 
    /// The schema_path should point to the baml_src directory.
    pub fn load_schema(&mut self, schema_path: &str) -> Result<()> {
        tracing::info!(schema_path = schema_path, "Loading BAML IL");
        
        use std::path::Path;
        use std::fs;
        
        // Find project root
        let schema_path_obj = Path::new(schema_path);
        let project_root = if schema_path_obj.is_file() {
            schema_path_obj.parent()
                .and_then(|p| p.parent())
        } else {
            if schema_path_obj.file_name() == Some(std::ffi::OsStr::new("baml_src")) {
                schema_path_obj.parent()
            } else {
                Some(schema_path_obj)
            }
        }
        .ok_or_else(|| BamlRtError::InvalidArgument("Invalid schema path".to_string()))?;
        
        let client_dir = project_root.join("baml_client");
        if !client_dir.exists() {
            return Err(BamlRtError::BamlRuntime(
                format!("baml_client directory not found. Run 'baml-cli generate' first.")
            ));
        }
        
        let baml_src_dir = project_root.join("baml_src");
        if !baml_src_dir.exists() {
            return Err(BamlRtError::BamlRuntime(
                "baml_src directory not found".to_string()
            ));
        }
        
        // Load BAML IL into executor
        self.executor = Some(BamlExecutor::load_il(&client_dir, &baml_src_dir)?);
        
        // Discover functions from generated code for registration
        let inlined_file = client_dir.join("inlinedbaml.ts");
        if inlined_file.exists() {
            let content = fs::read_to_string(&inlined_file)
                .map_err(|e| BamlRtError::Io(e))?;
            
            use regex::Regex;
            let re = Regex::new(r"function\s+(\w+)\s*\(").unwrap();
            for cap in re.captures_iter(&content) {
                let func_name = cap.get(1).unwrap().as_str().to_string();
                
                // Functions are discovered from the runtime's IR, not stored separately
                
                // Register function signature
                self.function_registry.insert(
                    func_name.clone(),
                    FunctionSignature {
                        name: func_name.clone(),
                        input_types: vec![],
                        output_type: crate::types::BamlType::String,
                    },
                );
            }
        }
        
        tracing::info!(
            function_count = self.function_registry.len(),
            "Loaded BAML IL"
        );
        
        Ok(())
    }

    /// Get the signature of a function by name
    pub fn get_function_signature(&self, name: &str) -> Option<&FunctionSignature> {
        self.function_registry.get(name)
    }

    /// Execute a BAML function with the given arguments
    pub async fn invoke_function(
        &self,
        function_name: &str,
        args: serde_json::Value,
    ) -> Result<serde_json::Value> {
        tracing::debug!(
            function = function_name,
            args = ?args,
            "Invoking BAML function"
        );

        // Verify function exists
        let _signature = self
            .function_registry
            .get(function_name)
            .ok_or_else(|| BamlRtError::FunctionNotFound(function_name.to_string()))?;

        // Execute the BAML function using the executor
        let executor = self.executor.as_ref()
            .ok_or_else(|| BamlRtError::BamlRuntime("BAML runtime not loaded".to_string()))?;
        
        executor.execute_function(function_name, args).await
    }

    /// Invoke a BAML function with streaming support
    /// 
    /// Returns a stream that yields incremental results as the function executes.
    pub fn invoke_function_stream(
        &self,
        function_name: &str,
        args: serde_json::Value,
    ) -> Result<baml_runtime::FunctionResultStream> {
        tracing::debug!(
            function = function_name,
            args = ?args,
            "Invoking BAML function with streaming"
        );

        // Verify function exists
        let _signature = self
            .function_registry
            .get(function_name)
            .ok_or_else(|| BamlRtError::FunctionNotFound(function_name.to_string()))?;

        // Execute the BAML function using the executor
        let executor = self.executor.as_ref()
            .ok_or_else(|| BamlRtError::BamlRuntime("BAML runtime not loaded".to_string()))?;
        
        executor.execute_function_stream(function_name, args)
    }

    /// List all available BAML functions
    pub fn list_functions(&self) -> Vec<String> {
        self.function_registry.keys().cloned().collect()
    }
}

impl Default for BamlRuntimeManager {
    fn default() -> Self {
        Self::new().expect("Failed to create BamlRuntimeManager")
    }
}

